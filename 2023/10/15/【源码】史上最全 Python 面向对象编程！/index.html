<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>史上最全 Python 面向对象编程 | Hello</title><meta name="author" content="sagonimikakokomi"><meta name="copyright" content="sagonimikakokomi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【源码】史上最全 Python 面向对象编程！ 转自：浪子燕青 http:&#x2F;&#x2F;www.langzi.fun&#x2F;Python面向对象编程.html  面向过程编程： 123456789导入各种外部库设计各种全局变量写一个函数完成某个功能写一个函数完成某个功能写一个函数完成某个功能写一个函数完成某个功能写一个函数完成某个功能......写一个main函数作为程序入口  在多函数程序中，许多重要的数据被放">
<meta property="og:type" content="article">
<meta property="og:title" content="史上最全 Python 面向对象编程">
<meta property="og:url" content="https://kokomisukisuki.github.io/2023/10/15/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%20Python%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%81/index.html">
<meta property="og:site_name" content="Hello">
<meta property="og:description" content="【源码】史上最全 Python 面向对象编程！ 转自：浪子燕青 http:&#x2F;&#x2F;www.langzi.fun&#x2F;Python面向对象编程.html  面向过程编程： 123456789导入各种外部库设计各种全局变量写一个函数完成某个功能写一个函数完成某个功能写一个函数完成某个功能写一个函数完成某个功能写一个函数完成某个功能......写一个main函数作为程序入口  在多函数程序中，许多重要的数据被放">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.helloimg.com/images/2023/10/03/oHEMrt.jpg">
<meta property="article:published_time" content="2023-10-14T16:00:00.000Z">
<meta property="article:modified_time" content="2023-10-18T13:54:15.672Z">
<meta property="article:author" content="sagonimikakokomi">
<meta property="article:tag" content="python基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.helloimg.com/images/2023/10/03/oHEMrt.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://kokomisukisuki.github.io/2023/10/15/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%20Python%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"UNK1PFAIM3","apiKey":"82e2706c98842df0554f4f4c562132c7","indexName":"kokomisuki","hits":{"per_page":20},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: sagonimikakokomi","link":"链接: ","source":"来源: Hello","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '史上最全 Python 面向对象编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-18 21:54:15'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="themes\butterfly\source\css\color.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="themes\butterfly\source\css\diy.css" media="print" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://ooo.0x0.ooo/2023/10/02/OnIWmL.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">144</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.helloimg.com/images/2023/10/03/oHsxEg.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello"><span class="site-name">Hello</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">史上最全 Python 面向对象编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-14T16:00:00.000Z" title="发表于 2023-10-15 00:00:00">2023-10-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-18T13:54:15.672Z" title="更新于 2023-10-18 21:54:15">2023-10-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/python/">python</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="【源码】史上最全-Python-面向对象编程！"><a href="#【源码】史上最全-Python-面向对象编程！" class="headerlink" title="【源码】史上最全 Python 面向对象编程！"></a>【源码】史上最全 Python 面向对象编程！</h1><blockquote>
<p>转自：浪子燕青</p>
<p><a target="_blank" rel="noopener" href="http://www.langzi.fun/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.html">http://www.langzi.fun/Python面向对象编程.html</a></p>
</blockquote>
<p><strong>面向过程编程：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">导入各种外部库</span><br><span class="line">设计各种全局变量</span><br><span class="line">写一个函数完成某个功能</span><br><span class="line">写一个函数完成某个功能</span><br><span class="line">写一个函数完成某个功能</span><br><span class="line">写一个函数完成某个功能</span><br><span class="line">写一个函数完成某个功能</span><br><span class="line">......</span><br><span class="line">写一个main函数作为程序入口</span><br></pre></td></tr></table></figure>

<p>在多函数程序中，<strong>许多重要的数据被放置在全局数据区</strong>，这样它们可以被所有的函数访问。每个函数都可以具有它们自己的局部数据，将某些功能代码封装到函数中，日后便无需重复编写，仅调用函数即可。</p>
<p><strong>从代码的组织形式来看就是根据业务逻辑从上到下垒代码 。</strong></p>
<p><strong>面向对象编程：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">导入各种外部库</span><br><span class="line">设计各种全局变量</span><br><span class="line">决定你要的类</span><br><span class="line">给每个类提供完整的一组操作</span><br><span class="line">明确地使用继承来表现不同类之间的共同点</span><br><span class="line">根据需要，决定是否写一个main函数作为程序入口</span><br></pre></td></tr></table></figure>

<p>面向对象编程中，将函数和变量进一步封装成类，<strong>类才是程序的基本元素</strong>，它将数据和操作紧密地连结在一起，并保护数据不会被外界的函数意外地改变。类和和类的实例（也称对象）是面向对象的核心概念，是和面向过程编程、函数式编程的根本区别。</p>
<p>并不是非要用面向对象编程，要看你的程序怎么设计方便，但是就目前来说，基本上都是在使用面向对象编程。</p>
<h3 id="类的基本用法"><a href="#类的基本用法" class="headerlink" title="类的基本用法"></a>类的基本用法</h3><p>面向对象是通过定义class类来定义，这么说面向对象编程就是只使用class类，在class类中有封装，继承的功能，并且还可以构造要传入的参数，方便控制。</p>
<h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">class studetn:</span><br><span class="line">    # 定义一个类名为studetn</span><br><span class="line">    def __init__(self,idx):</span><br><span class="line">    # 定义初始化构造，这里使用init，还有别的属性比如reversed，iter之类的</span><br><span class="line">        self.idx=idx</span><br><span class="line">        # 初始化变量，方便继承</span><br><span class="line">    def runx(self):</span><br><span class="line">    # 定义运行函数，从上面继承变量</span><br><span class="line">        print self.idx</span><br><span class="line">        # 打印出idx的值，或者做一些别的处理</span><br><span class="line">        time.sleep(1)</span><br><span class="line">a=studetn(&#x27;a&#x27;)</span><br><span class="line">a.runx()</span><br><span class="line"># 这是类的调用，一定要记得类的使用方法，首先传入参数，类赋值给一个变量a</span><br><span class="line"># 然后调用这个类下面定义的函数</span><br></pre></td></tr></table></figure>

<p>一些专业术语概念，既然有面向对象编程这个高大上的定义了，自然要搭配一些高大上的概念。</p>
<ol>
<li>类(Class): 用来描述具有相同属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。其中的对象被称作类的实例。</li>
<li>实例：也称对象。通过类定义的初始化方法，赋予具体的值，成为一个”有血有肉的实体”。</li>
<li>实例化：创建类的实例的过程或操作。</li>
<li>实例变量：定义在实例中的变量，只作用于当前实例。</li>
<li>类变量：类变量是所有实例公有的变量。类变量定义在类中，但在方法体之外。</li>
<li>数据成员：类变量、实例变量、方法、类方法、静态方法和属性等的统称。</li>
<li>方法：类中定义的函数。</li>
<li>静态方法：不需要实例化就可以由类执行的方法</li>
<li>类方法：类方法是将类本身作为对象进行操作的方法。</li>
<li>方法重写：如果从父类继承的方法不能满足子类的需求，可以对父类的方法进行改写，这个过程也称override。</li>
<li>封装：将内部实现包裹起来，对外透明，提供api接口进行调用的机制</li>
<li>继承：即一个派生类（derived class）继承父类（base class）的变量和方法。</li>
<li>多态：根据对象类型的不同以不同的方式进行处理。</li>
</ol>
<h3 id="类与实例"><a href="#类与实例" class="headerlink" title="类与实例"></a>类与实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : 2018/5/3 0003 17:02</span><br><span class="line"># @Author  : Langzi</span><br><span class="line"># @Blog    : www.langzi.fun</span><br><span class="line"># @File    : 面向对象2.py</span><br><span class="line"># @Software: PyCharm</span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">class cc:</span><br><span class="line">    ccc = &#x27;ccc&#x27;</span><br><span class="line">    # cc就是类名 如果想要继承别的类 就class cc(threading) 意思就是从threading继承</span><br><span class="line">    def __init__(self,a,b,c):</span><br><span class="line">        self.a=a</span><br><span class="line">        self.b=b</span><br><span class="line">        self.c=c</span><br><span class="line">        # 定义构造的过程就是实例化</span><br><span class="line">    def runx(self):</span><br><span class="line">        print self.a*10</span><br><span class="line">        print self.b*5</span><br><span class="line">        print self.c*2</span><br><span class="line">    def runy(self):</span><br><span class="line">        print requests.get(&#x27;http://www.langzi.fun&#x27;).headers</span><br><span class="line">e = cc(&#x27;AAA&#x27;,&#x27;CCC&#x27;,&#x27;EEE&#x27;)</span><br><span class="line">e.runx()</span><br><span class="line">e.runy()</span><br><span class="line"># 这两个就是调用类里面的方法</span><br><span class="line">print e.c</span><br><span class="line">#实例变量指的是实例本身拥有的变量。每个实例的变量在内存中都不一样。</span><br><span class="line">print e.ccc</span><br><span class="line">#类变量，在类里面找到定义的变量。</span><br></pre></td></tr></table></figure>

<h3 id="调用类的三种方法"><a href="#调用类的三种方法" class="headerlink" title="调用类的三种方法"></a>调用类的三种方法</h3><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : 2018/5/3 0003 17:16</span><br><span class="line"># @Author  : Langzi</span><br><span class="line"># @Blog    : www.langzi.fun</span><br><span class="line"># @File    : 面向对象3.py</span><br><span class="line"># @Software: PyCharm</span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">class dd:</span><br><span class="line">    def __init__(self,url):</span><br><span class="line">        self.url=url</span><br><span class="line">    def runx(self):</span><br><span class="line">        print requests.get(self.url).status_code</span><br><span class="line"></span><br><span class="line">a = dd(&#x27;http://www.langzi.fun&#x27;)</span><br><span class="line">a.runx()</span><br><span class="line"># 这种调用方法就是实例方法</span><br></pre></td></tr></table></figure>

<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>静态方法由类调用，无默认参数。将实例方法参数中的self去掉，然后在方法定义上方加上@staticmethod，就成为静态方法。它属于类，和实例无关。建议只使用类名.静态方法的调用方式。（虽然也可以使用实例名.静态方法的方式调用）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : 2018/5/3 0003 17:21</span><br><span class="line"># @Author  : Langzi</span><br><span class="line"># @Blog    : www.langzi.fun</span><br><span class="line"># @File    : 面向对象4.py</span><br><span class="line"># @Software: PyCharm</span><br><span class="line">import sys</span><br><span class="line">import requests</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&#x27;utf-8&#x27;)</span><br><span class="line">class ff:</span><br><span class="line">    @staticmethod</span><br><span class="line">    def runx():</span><br><span class="line">        print requests.get(&#x27;http://www.langzi.fun&#x27;).status_code</span><br><span class="line">ff.runx()</span><br><span class="line">#这里就直接调用了类的变量，只在类中运行而不在实例中运行的方法</span><br></pre></td></tr></table></figure>

<p>经常有一些跟类有关系的功能但在运行时又不需要实例和类参与的情况下需要用到静态方法. 比如更改环境变量或者修改其他类的属性等能用到静态方法. 这种情况可以直接用函数解决, 但这样同样会扩散类内部的代码，造成维护困难。</p>
<h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p>类方法由类调用，采用@classmethod装饰，至少传入一个cls（代指类本身，类似self）参数。执行类方法时，自动将调用该方法的类赋值给cls。建议只使用类名.类方法的调用方式。（虽然也可以使用实例名.类方法的方式调用）</p>
<h5 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h5><p>如果要构造一个类，接受一个网站和这个网站的状态码，然后打印出来。就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import requests</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&#x27;utf-8&#x27;)</span><br><span class="line">class gg:</span><br><span class="line">    def __init__(self,url,stat):</span><br><span class="line">        self.url=url</span><br><span class="line">        self.stat=stat</span><br><span class="line">    def outer(self):</span><br><span class="line">        print self.url</span><br><span class="line">        print self.stat</span><br><span class="line">a = gg(&#x27;langzi&#x27;,200)</span><br><span class="line">a.outer()</span><br></pre></td></tr></table></figure>

<p>这样就是使用实例方法，虽然可以实现，但是有的时候传入的参数并不是(‘langzi’,200)这样的格式，而是(‘langzi-200’)这样的，那该怎么做？首先要把这个拆分，但是要使用实例方法实现起来很麻烦，这个时候就可以使用类方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : 2018/5/3 0003 17:27</span><br><span class="line"># @Author  : Langzi</span><br><span class="line"># @Blog    : www.langzi.fun</span><br><span class="line"># @File    : 面向对象5.py</span><br><span class="line"># @Software: PyCharm</span><br><span class="line">import sys</span><br><span class="line">import requests</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&#x27;utf-8&#x27;)</span><br><span class="line">class gg:</span><br><span class="line">    url = 0</span><br><span class="line">    stat = 0</span><br><span class="line">    # 因为使用classmethod后会传入新的变量，所以一开始是需要自己先定义类变量</span><br><span class="line">    def __init__(self,url=0,stat=0):</span><br><span class="line">    # 这里按照正常的定义构造函数</span><br><span class="line">        self.url=url</span><br><span class="line">        self.stat=stat</span><br><span class="line">    @classmethod</span><br><span class="line">    # 装饰器，立马执行下面的函数</span><br><span class="line">    def split(cls,info):</span><br><span class="line">        # 这个函数接受两个参数，默认的cls就是这个类的init函数，info就是外面传入进来的</span><br><span class="line">        url,stat=map(str,info.split(&#x27;-&#x27;))</span><br><span class="line">        # 这里转换成了格式化的结构</span><br><span class="line">        data = cls(url,stat)</span><br><span class="line">        # 然后执行这个类第一个方法，这个类构造函数需要传入两个参数，于是就传入了两个参数</span><br><span class="line">        return data</span><br><span class="line">        # 这里就直接返回了函数结果</span><br><span class="line">    def outer(self):</span><br><span class="line">        print self.url</span><br><span class="line">        print self.stat</span><br><span class="line"></span><br><span class="line">r = gg.split((&#x27;langzi-200&#x27;))</span><br><span class="line">r.outer()</span><br><span class="line"># 这里是调用类方法，与调用实例方法一样</span><br></pre></td></tr></table></figure>

<h3 id="类的特性"><a href="#类的特性" class="headerlink" title="类的特性"></a>类的特性</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是指将数据与具体操作的实现代码放在某个对象内部，外部无法访问。必须要先调用类的方法才能启动。</p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class cc:</span><br><span class="line">    ccc = &#x27;ccc&#x27;</span><br><span class="line">    # cc就是类名 如果想要继承别的类 就class cc(threading) 意思就是从threading继承</span><br><span class="line">    def __init__(self,a,b,c):</span><br><span class="line">        self.a=a</span><br><span class="line">        self.b=b</span><br><span class="line">        self.c=c</span><br><span class="line">print e.ccc</span><br><span class="line">#类变量，在类里面找到定义的变量。</span><br><span class="line">print ccc</span><br><span class="line"># 这里会报错，这就是封装。类中的函数同理。</span><br></pre></td></tr></table></figure>

<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。<br>比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Animal(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print &#x27;Animal is running...&#x27;</span><br></pre></td></tr></table></figure>

<p>当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Animal):</span><br><span class="line">    pass</span><br><span class="line">class Cat(Animal):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>继承有什么好处？最大的好处是子类获得了父类的全部功能。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dog = Dog()</span><br><span class="line">dog.run()</span><br><span class="line">cat = Cat()</span><br><span class="line">cat.run()</span><br></pre></td></tr></table></figure>

<p>当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def run_twice(animal):</span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br></pre></td></tr></table></figure>

<p>当我们传入Animal的实例时，run_twice()就打印出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run_twice(Animal())</span><br><span class="line">运行结果：</span><br><span class="line">Animal is running...</span><br><span class="line">Animal is running...</span><br></pre></td></tr></table></figure>

<p>当我们传入Dog的实例时，run_twice()就打印出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run_twice(Dog())</span><br><span class="line">运行结果：</span><br><span class="line">Dog is running...</span><br><span class="line">Dog is running...</span><br></pre></td></tr></table></figure>

<p>当我们传入Cat的实例时，run_twice()就打印出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run_twice(Cat())</span><br><span class="line">运行结果：</span><br><span class="line">Cat is running...</span><br><span class="line">Cat is running...</span><br></pre></td></tr></table></figure>

<p>看上去没啥意思，但是仔细想想，现在，如果我们再定义一个Tortoise类型，也从Animal派生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Tortoise(Animal):</span><br><span class="line">    def run(self):</span><br><span class="line">        print &#x27;Tortoise is running slowly...&#x27;</span><br></pre></td></tr></table></figure>

<p>当我们调用run_twice()时，传入Tortoise的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run_twice(Tortoise())</span><br><span class="line">运行结果：</span><br><span class="line">Tortoise is running slowly...</span><br><span class="line">Tortoise is running slowly...</span><br></pre></td></tr></table></figure>

<p>你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。</p>
<p>多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思：</p>
<p>对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p>
<p>对扩展开放：允许新增Animal子类；<br>对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。<br>总结：继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写；<br>有了继承，才能有多态。在调用类实例方法的时候，尽量把变量视作父类类型，这样，所有子类类型都可以正常被接收；<br>旧的方式定义Python类允许不从object类继承，但这种编程方式已经严重不推荐使用。任何时候，如果没有合适的类可以继承，就继承自object类。</p>
<h3 id="魔法方法"><a href="#魔法方法" class="headerlink" title="魔法方法"></a>魔法方法</h3><p>在上面有提到除了<strong>init</strong>之外还有iter,reverse的方法，这里就详细说下除了init初始化还有哪些别的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__init__ :      构造函数，在生成对象时调用</span><br><span class="line">__del__ :       析构函数，释放对象时使用</span><br><span class="line">__repr__ :      打印，转换</span><br><span class="line">__setitem__ :   按照索引赋值</span><br><span class="line">__getitem__:    按照索引获取值</span><br><span class="line">__len__:        获得长度</span><br><span class="line">__cmp__:        比较运算</span><br><span class="line">__call__:       调用</span><br><span class="line">__add__:        加运算</span><br><span class="line">__sub__:        减运算</span><br><span class="line">__mul__:        乘运算</span><br><span class="line">__div__:        除运算</span><br><span class="line">__mod__:        求余运算</span><br><span class="line">__pow__:        幂</span><br></pre></td></tr></table></figure>

<h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><h5 id="1-doc"><a href="#1-doc" class="headerlink" title="1. doc"></a>1. <strong>doc</strong></h5><p>说明性文档和信息。Python自建，无需自定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    &quot;&quot;&quot; 描述类信息，可被自动收集 &quot;&quot;&quot;</span><br><span class="line">    def func(self):</span><br><span class="line">        pass</span><br><span class="line"># 打印类的说明文档 </span><br><span class="line">print(Foo.__doc__)</span><br></pre></td></tr></table></figure>

<h5 id="2-init"><a href="#2-init" class="headerlink" title="2. init()"></a>2. <strong>init</strong>()</h5><p>实例化方法，通过类创建实例时，自动触发执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = 18</span><br><span class="line">obj = Foo(jack&#x27;) # 自动执行类中的 __init__ 方法</span><br></pre></td></tr></table></figure>

<h5 id="3-module-和-class"><a href="#3-module-和-class" class="headerlink" title="3. module__ 和 __class"></a>3. <strong>module__ 和 __class</strong></h5><p>module 表示当前操作的对象在属于哪个模块。<br>class 表示当前操作的对象属于哪个类。<br>这两者也是Python内建，无需自定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    pass</span><br><span class="line">obj = Foo()</span><br><span class="line">print(obj.__module__)</span><br><span class="line">print(obj.__class__)</span><br><span class="line">运行结果：</span><br><span class="line">main</span><br></pre></td></tr></table></figure>

<h5 id="4-del"><a href="#4-del" class="headerlink" title="4. del()"></a>4. <strong>del</strong>()</h5><p>析构方法，当对象在内存中被释放时，自动触发此方法。</p>
<p>注：此方法一般无须自定义，因为Python自带内存分配和释放机制，除非你需要在释放的时候指定做一些动作。析构函数的调用是由解释器在进行垃圾回收时自动触发执行的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;我被回收了！&quot;)</span><br><span class="line"></span><br><span class="line">obj = Foo()</span><br><span class="line">del obj</span><br></pre></td></tr></table></figure>

<h5 id="5-call"><a href="#5-call" class="headerlink" title="5. call()"></a>5. <strong>call</strong>()</h5><p>如果为一个类编写了该方法，那么在该类的实例后面加括号，可会调用这个方法。</p>
<p>注：构造方法的执行是由类加括号执行的，即：对象 &#x3D; 类名()，而对于call() 方法，是由对象后加括号触发的，即：对象() 或者 类()()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(&#x27;__call__&#x27;)</span><br><span class="line">obj = Foo()     # 执行 __init__</span><br><span class="line">obj()       # 执行 __call__</span><br></pre></td></tr></table></figure>

<p>可以用Python内建的callable()函数进行测试，判断一个对象是否可以被执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callable(Student())</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure>

<h5 id="6-dict"><a href="#6-dict" class="headerlink" title="6. dict"></a>6. <strong>dict</strong></h5><p>列出类或对象中的所有成员！非常重要和有用的一个属性，Python自建，无需用户自己定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Province:</span><br><span class="line">    country = &#x27;China&#x27;</span><br><span class="line">    def __init__(self, name, count):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.count = count</span><br><span class="line">    def func(self, *args, **kwargs):</span><br><span class="line">        print（&#x27;func&#x27;）</span><br><span class="line"># 获取类的成员</span><br><span class="line">print(Province.__dict__)</span><br><span class="line"># 获取 对象obj1 的成员 </span><br><span class="line">obj1 = Province(&#x27;HeBei&#x27;,10000)</span><br><span class="line">print(obj1.__dict__)</span><br><span class="line"># 获取 对象obj2 的成员 </span><br><span class="line">obj2 = Province(&#x27;HeNan&#x27;, 3888)</span><br><span class="line">print(obj2.__dict__)</span><br></pre></td></tr></table></figure>

<h5 id="7-str"><a href="#7-str" class="headerlink" title="7. str()"></a>7. <strong>str</strong>()</h5><p>如果一个类中定义了str()方法，那么在打印对象时，默认输出该方法的返回值。这也是一个非常重要的方法，需要用户自己定义。　</p>
<p>下面的类，没有定义str()方法，打印结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    pass</span><br><span class="line">obj = Foo()</span><br><span class="line">print(obj)</span><br><span class="line">定义了__str__()方法后，打印结果是：&#x27;jack&#x27;。</span><br><span class="line">class Foo:</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &#x27;jack&#x27;</span><br><span class="line">obj = Foo()</span><br><span class="line">print(obj)</span><br></pre></td></tr></table></figure>

<h5 id="8、getitem-、-setitem-、-delitem"><a href="#8、getitem-、-setitem-、-delitem" class="headerlink" title="8、getitem__()、*setitem*()、__delitem()"></a>8、<strong>getitem__()、*<em>setitem</em>*()、__delitem</strong>()</h5><p>取值、赋值、删除这“三剑客”的套路，在Python中，我们已经见过很多次了，比如前面的@property装饰器。</p>
<p>Python中，标识符后面加圆括号，通常代表执行或调用方法的意思。而在标识符后面加中括号[]，通常代表取值的意思。Python设计了getitem()、setitem()、delitem()这三个特殊成员，用于执行与中括号有关的动作。它们分别表示取值、赋值、删除数据。</p>
<p>也就是如下的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 标识符[]　： 　　执行__getitem__方法</span><br><span class="line">标识符[] = a  ： 　　执行__setitem__方法</span><br><span class="line">del 标识符[]　： 　　执行__delitem__方法</span><br></pre></td></tr></table></figure>

<p>如果有一个类同时定义了这三个魔法方法，那么这个类的实例的行为看起来就像一个字典一样，如下例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __getitem__(self, key):</span><br><span class="line">        print(&#x27;__getitem__&#x27;,key)</span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        print(&#x27;__setitem__&#x27;,key,value)</span><br><span class="line">    def __delitem__(self, key):</span><br><span class="line">        print(&#x27;__delitem__&#x27;,key)</span><br><span class="line">obj = Foo()</span><br><span class="line">result = obj[&#x27;k1&#x27;]      # 自动触发执行 __getitem__</span><br><span class="line">obj[&#x27;k2&#x27;] = &#x27;jack&#x27;      # 自动触发执行 __setitem__</span><br><span class="line">del obj[&#x27;k1&#x27;]             # 自动触发执行 __delitem__</span><br></pre></td></tr></table></figure>

<h5 id="9-iter"><a href="#9-iter" class="headerlink" title="9. iter()"></a>9. <strong>iter</strong>()</h5><p>这是迭代器方法！列表、字典、元组之所以可以进行for循环，是因为其内部定义了 iter()这个方法。如果用户想让自定义的类的对象可以被迭代，那么就需要在类中定义这个方法，并且让该方法的返回值是一个可迭代的对象。当在代码中利用for循环遍历对象时，就会调用类的这个iter()方法。</p>
<p>普通的类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    pass</span><br><span class="line">obj = Foo()</span><br><span class="line">for i in obj:</span><br><span class="line">    print(i)</span><br><span class="line"># 报错：TypeError: &#x27;Foo&#x27; object is not iterable&lt;br&gt;# 原因是Foo对象不可迭代</span><br><span class="line">添加一个__iter__()，但什么都不返回：</span><br><span class="line">class Foo:</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        pass</span><br><span class="line">obj = Foo()</span><br><span class="line">for i in obj:</span><br><span class="line">    print(i)</span><br><span class="line"># 报错：TypeError: iter() returned non-iterator of type &#x27;NoneType&#x27;</span><br><span class="line">#原因是 __iter__方法没有返回一个可迭代的对象</span><br></pre></td></tr></table></figure>

<p>返回一个个迭代对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self, sq):</span><br><span class="line">        self.sq = sq</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return iter(self.sq)</span><br><span class="line">obj = Foo([11,22,33,44])</span><br><span class="line">for i in obj:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<p>最好的方法是使用生成器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        yield 1</span><br><span class="line">        yield 2</span><br><span class="line">        yield 3</span><br><span class="line">obj = Foo()</span><br><span class="line">for i in obj:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<h5 id="10、len"><a href="#10、len" class="headerlink" title="10、len()"></a>10、<strong>len</strong>()</h5><p>在Python中，如果你调用内置的len()函数试图获取一个对象的长度，在后台，其实是去调用该对象的len()方法，所以，下面的代码是等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">len(&#x27;ABC&#x27;)</span><br><span class="line">3</span><br><span class="line">&#x27;ABC&#x27;.__len__()</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>Python的list、dict、str等内置数据类型都实现了该方法，但是你自定义的类要实现len方法需要好好设计。</p>
<h5 id="11-repr"><a href="#11-repr" class="headerlink" title="11. repr()"></a>11. <strong>repr</strong>()</h5><p>这个方法的作用和str()很像，两者的区别是str()返回用户看到的字符串，而repr()返回程序开发者看到的字符串，也就是说，repr()是为调试服务的。通常两者代码一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &quot;this is %s&quot; % self.name</span><br><span class="line">    __repr__ = __str__</span><br></pre></td></tr></table></figure>

<h5 id="12-add-加运算-sub-减运算-mul-乘运算-div-除运算-mod-求余运算-pow-幂运算"><a href="#12-add-加运算-sub-减运算-mul-乘运算-div-除运算-mod-求余运算-pow-幂运算" class="headerlink" title="12. add__: 加运算 *sub*: 减运算 *mul*: 乘运算 *div*: 除运算 *mod*: 求余运算 __pow: 幂运算"></a>12. <strong>add__: 加运算 *<em>sub</em>*: 减运算 *<em>mul</em>*: 乘运算 *<em>div</em>*: 除运算 *<em>mod</em>*: 求余运算 __pow</strong>: 幂运算</h5><p>这些都是算术运算方法，需要你自己为类设计具体运算代码。有些Python内置数据类型，比如int就带有这些方法。Python支持运算符的重载，也就是重写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Vector:</span><br><span class="line">   def __init__(self, a, b):</span><br><span class="line">      self.a = a</span><br><span class="line">      self.b = b</span><br><span class="line">   def __str__(self):</span><br><span class="line">      return &#x27;Vector (%d, %d)&#x27; % (self.a, self.b)</span><br><span class="line">   def __add__(self,other):</span><br><span class="line">      return Vector(self.a + other.a, self.b + other.b)</span><br><span class="line">v1 = Vector(2,10)</span><br><span class="line">v2 = Vector(5,-2)</span><br><span class="line">print (v1 + v2)</span><br></pre></td></tr></table></figure>

<h5 id="13-author作者信息"><a href="#13-author作者信息" class="headerlink" title="13. author作者信息"></a>13. <strong>author</strong>作者信息</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__author__ = &quot;Jack&quot;</span><br><span class="line">def show():</span><br><span class="line">    print(__author__)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure>

<h5 id="14-slots"><a href="#14-slots" class="headerlink" title="14. slots"></a>14. <strong>slots</strong></h5><p>Python作为一种动态语言，可以在类定义完成和实例化后，给类或者对象继续添加随意个数或者任意类型的变量或方法，这是动态语言的特性。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def print_doc(self):</span><br><span class="line">    print(&quot;haha&quot;)</span><br><span class="line"></span><br><span class="line">class Foo:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">obj1 = Foo()</span><br><span class="line">obj2 = Foo()</span><br><span class="line"># 动态添加实例变量</span><br><span class="line">obj1.name = &quot;jack&quot;</span><br><span class="line">obj2.age = 18</span><br><span class="line"># 动态的给类添加实例方法</span><br><span class="line">Foo.show = print_doc</span><br><span class="line">obj1.show()</span><br><span class="line">obj2.show()</span><br></pre></td></tr></table></figure>

<p>但是！如果我想限制实例可以添加的变量怎么办？可以使slots限制实例的变量，比如，只允许Foo的实例添加name和age属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def print_doc(self):</span><br><span class="line">    print(&quot;haha&quot;)</span><br><span class="line">class Foo:</span><br><span class="line">    __slots__ = (&quot;name&quot;, &quot;age&quot;)</span><br><span class="line">    pass</span><br><span class="line">obj1 = Foo()</span><br><span class="line">obj2 = Foo()</span><br><span class="line"># 动态添加实例变量</span><br><span class="line">obj1.name = &quot;jack&quot;</span><br><span class="line">obj2.age = 18</span><br><span class="line">obj1.sex = &quot;male&quot;       # 这一句会弹出错误</span><br><span class="line"># 但是无法限制给类添加方法</span><br><span class="line">Foo.show = print_doc</span><br><span class="line">obj1.show()</span><br><span class="line">obj2.show()</span><br><span class="line">由于&#x27;sex&#x27;不在__slots__的列表中，所以不能绑定sex属性，试图绑定sex将得到AttributeError的错误。</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;F:/Python/pycharm/201705/1.py&quot;, line 14, in &lt;module&gt;</span><br><span class="line">    obj1.sex = &quot;male&quot;</span><br><span class="line">AttributeError: &#x27;Foo&#x27; object has no attribute &#x27;sex&#x27;</span><br></pre></td></tr></table></figure>

<p>需要提醒的是，slots定义的属性仅对当前类的实例起作用，对继承了它的子类是不起作用的。想想也是这个道理，如果你继承一个父类，却莫名其妙发现有些变量无法定义，那不是大问题么？如果非要子类也被限制，除非在子类中也定义slots，这样，子类实例允许定义的属性就是自身的slots加上父类的slots。</p>
<h3 id="成员保护与访问机制"><a href="#成员保护与访问机制" class="headerlink" title="成员保护与访问机制"></a>成员保护与访问机制</h3><p>有些对象你不想外部访问，即使是通过调用类对象也无法访问，那就请认真学完本章节。</p>
<h4 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class obj:</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name=name</span><br><span class="line">    def pri(self):</span><br><span class="line">        print self.name</span><br><span class="line">    __age = 18</span><br><span class="line">    # 加上双下划线的就是私有变量，只能在类的内部访问，外部无法访问</span><br><span class="line">a = obj(&#x27;zhao&#x27;)</span><br><span class="line">a.pri()</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhao</span><br></pre></td></tr></table></figure>

<p>如果要在类中调用这个私有成员，可以这么用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class obj:</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name=name</span><br><span class="line">    def prin(self):</span><br><span class="line">        print self.name</span><br><span class="line">    __age = 18</span><br><span class="line">    # 加上双下划线的就是私有变量，只能在类的内部访问，外部无法访问</span><br><span class="line">    @classmethod</span><br><span class="line">    # 如果要在类中调用，首先调用类方法</span><br><span class="line">    def pri(cls):</span><br><span class="line">        print cls.__age</span><br><span class="line">        # 然后在使用</span><br><span class="line">a = obj(&#x27;zhao&#x27;)</span><br><span class="line">a.prin()</span><br><span class="line">obj.pri()</span><br><span class="line"># 通过这样直接调用类中的私有变量</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhao</span><br><span class="line">18</span><br></pre></td></tr></table></figure>

<h4 id="使用get-set-del方法操作私有成员"><a href="#使用get-set-del方法操作私有成员" class="headerlink" title="使用get-set-del方法操作私有成员"></a>使用get-set-del方法操作私有成员</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class obj:</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name=name</span><br><span class="line">    def prin(self):</span><br><span class="line">        print self.name</span><br><span class="line">    __age = 18</span><br><span class="line">    # 加上双下划线的就是私有变量，只能在类的内部访问，外部无法访问</span><br><span class="line">    @classmethod</span><br><span class="line">    # 如果要在类中调用，首先调用类方法</span><br><span class="line">    def pri(cls):</span><br><span class="line">        print cls.__age</span><br><span class="line">        # 然后在使用</span><br><span class="line">    @classmethod</span><br><span class="line">    def set_age(cls,value):</span><br><span class="line">        cls.__age = value</span><br><span class="line">        return cls.__age</span><br><span class="line">        # 这个用法就是改变__age的值</span><br><span class="line">    @classmethod</span><br><span class="line">    def get_age(cls):</span><br><span class="line">        return cls.__age</span><br><span class="line">        # 这个用法就是直接返回__age的值</span><br><span class="line">    @classmethod</span><br><span class="line">    def del_age(cls):</span><br><span class="line">        del cls.__age</span><br><span class="line">        # 这个用法就是直接删除__age的值</span><br><span class="line"></span><br><span class="line">print obj.get_age()</span><br><span class="line"># 这里是直接调用出__age的值  返回值18</span><br><span class="line">print obj.set_age(20)</span><br><span class="line"># 这里是直接改变__age的值  返回值20</span><br><span class="line">obj.del_age()</span><br><span class="line"># 这里是直接删除__age的值</span><br></pre></td></tr></table></figure>

<p>思考： 既然是私有变量，不让外部访问，为何有要在后面调用又改变呢？因为可以对私有变量进行额外的检测，处理，加工等等。比如判断value的值，使用isinstance然后做if-else判断。</p>
<p>使用私有变量可以对内部变量进行保护，外部无法改变，但是可以对它进行检测处理。</p>
<p>这里引申一下私有成员的保护机制，使用__age对私有变量其实就是—&gt;obj._obj__age的样子进行保护，说白了你直接使用obj._obj__age就可以直接调用内部私有变量age了。</p>
<h3 id="Propety装饰器"><a href="#Propety装饰器" class="headerlink" title="Propety装饰器"></a>Propety装饰器</h3><p>把类的方法伪装成属性调用的方式，就是把类里面的一个函数，变成一个属性一样的东西~<br>一开始调用类的方法要使用圆括号，现在变成了属性进行读取设置存储。<br>举个例子来说明：</p>
<h4 id="常用的调用方法"><a href="#常用的调用方法" class="headerlink" title="常用的调用方法"></a>常用的调用方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class obj:</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.__name=name</span><br><span class="line">        self.__age=age</span><br><span class="line">        # 讲这些设置成私有变量</span><br><span class="line">    def get_age(self):</span><br><span class="line">        return self.__age</span><br><span class="line">    def set_age(self,value):</span><br><span class="line">        if isinstance(value,int):</span><br><span class="line">            self.__age=value</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(&#x27;非整数类型&#x27;)</span><br><span class="line">    def del_age(self):</span><br><span class="line">        print &#x27;delete over&#x27;</span><br><span class="line">a = obj(&#x27;langzi&#x27;,18)</span><br><span class="line">print a.get_age()</span><br><span class="line">a.set_age(20)</span><br><span class="line">print a.get_age()</span><br></pre></td></tr></table></figure>

<h4 id="使用装饰器"><a href="#使用装饰器" class="headerlink" title="使用装饰器"></a>使用装饰器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class obj:</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.__name=name</span><br><span class="line">        self.__age=age</span><br><span class="line">        # 把这些设置成私有变量</span><br><span class="line">    @property</span><br><span class="line">    def age(self):</span><br><span class="line">        return self.__age</span><br><span class="line">    @age.setter</span><br><span class="line">    def age(self,value):</span><br><span class="line">        if isinstance(value,int):</span><br><span class="line">            self.__age=value</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(&#x27;非整数类型&#x27;)</span><br><span class="line">    @age.deleter</span><br><span class="line">    def age(self):</span><br><span class="line">        print &#x27;delete over&#x27;</span><br><span class="line">a = obj(&#x27;langzi&#x27;,18)</span><br><span class="line"># 使用这些装饰器，可以使用类与对象的方法直接调用</span><br><span class="line">print a.age</span><br><span class="line"># 这里就是直接调用返回age的值</span><br><span class="line">a.age=20</span><br><span class="line"># 这里就是直接使用setter把值转换</span><br><span class="line">print a.age</span><br><span class="line">del a.age</span><br><span class="line"># 删除age</span><br></pre></td></tr></table></figure>

<p>当然这种调用方法有些麻烦，每次都是一个一个去实例类与对象，有个更加简单直观的方法。</p>
<h4 id="更加减半的使用property-函数"><a href="#更加减半的使用property-函数" class="headerlink" title="更加减半的使用property()函数"></a>更加减半的使用property()函数</h4><p>除了使用装饰器的方式将一个方法伪装成属性外，Python内置的builtins模块中的property()函数，为我们提供了第二种设置类属性的手段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class People:</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line">    def get_age(self):</span><br><span class="line">        return self.__age</span><br><span class="line"></span><br><span class="line">    def set_age(self, age):</span><br><span class="line">        if isinstance(age, int):</span><br><span class="line">            self.__age = age</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError</span><br><span class="line"></span><br><span class="line">    def del_age(self):</span><br><span class="line">        print(&quot;删除年龄数据！&quot;)</span><br><span class="line"></span><br><span class="line">    # 核心在这句</span><br><span class="line">    age = property(get_age, set_age, del_age, &quot;年龄&quot;)    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = People(&quot;jack&quot;, 18)</span><br><span class="line">print(obj.age)</span><br><span class="line">obj.age = 19</span><br><span class="line">print(&quot;obj.age:  &quot;, obj.age)</span><br><span class="line">del obj.ag</span><br></pre></td></tr></table></figure>

<p>通过语句age &#x3D; property(get_age, set_age, del_age, “年龄”)将一个方法伪装成为属性。其效果和装饰器的方法是一样的。</p>
<p>property()函数的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一个参数是方法名，调用 实例.属性 时自动执行的方法</span><br><span class="line">第二个参数是方法名，调用 实例.属性 ＝ XXX时自动执行的方法</span><br><span class="line">第三个参数是方法名，调用 del 实例.属性 时自动执行的方法</span><br><span class="line">第四个参数是字符串，调用 实例.属性.__doc__时的描述信息。</span><br></pre></td></tr></table></figure>





</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://kokomisukisuki.github.io">sagonimikakokomi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://kokomisukisuki.github.io/2023/10/15/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%20Python%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%81/">https://kokomisukisuki.github.io/2023/10/15/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%20Python%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://kokomisukisuki.github.io" target="_blank">Hello</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python%E5%9F%BA%E7%A1%80/">python基础</a></div><div class="post_share"><div class="social-share" data-image="https://www.helloimg.com/images/2023/10/03/oHEMrt.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/15/%E3%80%90%E5%B9%B2%E8%B4%A7%E3%80%91%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%81/" title="一文详解Python多线程、多进程！"><img class="cover" src="https://www.helloimg.com/images/2023/10/03/oHJyqP.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">一文详解Python多线程、多进程！</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/15/%E3%80%90%E6%94%B6%E8%97%8F%E3%80%91Python%20%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%85%AB%E7%A7%8D%E6%96%B9%E6%A1%88%EF%BC%81/" title="Python 实现定时任务的八种方案！"><img class="cover" src="https://www.helloimg.com/images/2023/10/03/oHElOQ.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Python 实现定时任务的八种方案！</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/10/07/Python%20%20Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/" title="Python学习之多线程详解"><img class="cover" src="https://www.helloimg.com/images/2023/10/03/oHE8ZA.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">Python学习之多线程详解</div></div></a></div><div><a href="/2023/10/07/Python%20%20Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3/" title="Python学习之多进程详解"><img class="cover" src="https://www.helloimg.com/images/2023/10/03/oHEI6z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">Python学习之多进程详解</div></div></a></div><div><a href="/2023/10/07/Python%20%20asyncio%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E3%80%81%E6%BA%90%E7%A0%81%E5%88%B0%E5%AE%9E%E7%8E%B0/" title="asyncio：从原理、源码到实现"><img class="cover" src="https://www.helloimg.com/images/2023/10/03/oHEpr6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">asyncio：从原理、源码到实现</div></div></a></div><div><a href="/2023/10/17/cookie%E8%AF%A6%E8%A7%A3/" title="cookie详解"><img class="cover" src="https://www.helloimg.com/images/2023/10/03/oHENJM.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-17</div><div class="title">cookie详解</div></div></a></div><div><a href="/2023/10/17/python%E4%B8%AD%20r'',%20b'',%20u'',%20f''%20%E7%9A%84%E5%90%AB%E4%B9%89/" title="python中 r&#39;&#39;, b&#39;&#39;, u&#39;&#39;, f&#39;&#39; 的含义"><img class="cover" src="https://www.helloimg.com/images/2023/10/03/oHEwug.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-17</div><div class="title">python中 r&#39;&#39;, b&#39;&#39;, u&#39;&#39;, f&#39;&#39; 的含义</div></div></a></div><div><a href="/2023/10/17/python%E5%9F%BA%E7%A1%80raise/" title="python基础raise"><img class="cover" src="https://www.helloimg.com/images/2023/10/03/oHXBKY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-17</div><div class="title">python基础raise</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8-Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%81"><span class="toc-text">【源码】史上最全 Python 面向对象编程！</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">类的基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%80"><span class="toc-text">案例一</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AE%9E%E4%BE%8B"><span class="toc-text">类与实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E7%B1%BB%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">调用类的三种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-text">实例方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B"><span class="toc-text">实际案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">类的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95"><span class="toc-text">魔法方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="toc-text">具体使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-doc"><span class="toc-text">1. doc</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-init"><span class="toc-text">2. init()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-module-%E5%92%8C-class"><span class="toc-text">3. module__ 和 __class</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-del"><span class="toc-text">4. del()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-call"><span class="toc-text">5. call()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-dict"><span class="toc-text">6. dict</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-str"><span class="toc-text">7. str()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81getitem-%E3%80%81-setitem-%E3%80%81-delitem"><span class="toc-text">8、getitem__()、*setitem*()、__delitem()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-iter"><span class="toc-text">9. iter()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81len"><span class="toc-text">10、len()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-repr"><span class="toc-text">11. repr()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-add-%E5%8A%A0%E8%BF%90%E7%AE%97-sub-%E5%87%8F%E8%BF%90%E7%AE%97-mul-%E4%B9%98%E8%BF%90%E7%AE%97-div-%E9%99%A4%E8%BF%90%E7%AE%97-mod-%E6%B1%82%E4%BD%99%E8%BF%90%E7%AE%97-pow-%E5%B9%82%E8%BF%90%E7%AE%97"><span class="toc-text">12. add__: 加运算 *sub*: 减运算 *mul*: 乘运算 *div*: 除运算 *mod*: 求余运算 __pow: 幂运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-author%E4%BD%9C%E8%80%85%E4%BF%A1%E6%81%AF"><span class="toc-text">13. author作者信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-slots"><span class="toc-text">14. slots</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E4%BF%9D%E6%8A%A4%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%9C%BA%E5%88%B6"><span class="toc-text">成员保护与访问机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98"><span class="toc-text">私有成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8get-set-del%E6%96%B9%E6%B3%95%E6%93%8D%E4%BD%9C%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98"><span class="toc-text">使用get-set-del方法操作私有成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Propety%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">Propety装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">常用的调用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">使用装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%8A%A0%E5%87%8F%E5%8D%8A%E7%9A%84%E4%BD%BF%E7%94%A8property-%E5%87%BD%E6%95%B0"><span class="toc-text">更加减半的使用property()函数</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By sagonimikakokomi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">welcome</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async defer src='themes\butterfly\source\js\diy.js'></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>