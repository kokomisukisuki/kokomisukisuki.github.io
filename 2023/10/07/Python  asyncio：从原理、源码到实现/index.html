<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>asyncio：从原理、源码到实现 | Hello</title><meta name="author" content="sagonimikakokomi"><meta name="copyright" content="sagonimikakokomi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Python | asyncio：从原理、源码到实现闲谈后 咸鱼学Python;) 2019-12-25 14:30 选自《源码读Python》 作者：闲谈后 https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;64991670 去年的这个时候吧，我开始找工作，招聘启事上说，需要了解 asyncio。 我回去翻了翻书，orz····· 今年，在一次内部技术分享会上，我要分享的内容涉及到一">
<meta property="og:type" content="article">
<meta property="og:title" content="asyncio：从原理、源码到实现">
<meta property="og:url" content="https://kokomisukisuki.github.io/2023/10/07/Python%20%20asyncio%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E3%80%81%E6%BA%90%E7%A0%81%E5%88%B0%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="Hello">
<meta property="og:description" content="Python | asyncio：从原理、源码到实现闲谈后 咸鱼学Python;) 2019-12-25 14:30 选自《源码读Python》 作者：闲谈后 https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;64991670 去年的这个时候吧，我开始找工作，招聘启事上说，需要了解 asyncio。 我回去翻了翻书，orz····· 今年，在一次内部技术分享会上，我要分享的内容涉及到一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.helloimg.com/images/2023/10/03/oHEpr6.jpg">
<meta property="article:published_time" content="2023-10-06T16:00:00.000Z">
<meta property="article:modified_time" content="2023-10-23T11:03:14.243Z">
<meta property="article:author" content="sagonimikakokomi">
<meta property="article:tag" content="python基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.helloimg.com/images/2023/10/03/oHEpr6.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://kokomisukisuki.github.io/2023/10/07/Python%20%20asyncio%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E3%80%81%E6%BA%90%E7%A0%81%E5%88%B0%E5%AE%9E%E7%8E%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"UNK1PFAIM3","apiKey":"82e2706c98842df0554f4f4c562132c7","indexName":"kokomisuki","hits":{"per_page":20},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: sagonimikakokomi","link":"链接: ","source":"来源: Hello","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'asyncio：从原理、源码到实现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-23 19:03:14'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/color.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/css/diy.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.css"/><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://ooo.0x0.ooo/2023/10/02/OnIWmL.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">213</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.helloimg.com/images/2023/10/04/oHL3KP.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello"><span class="site-name">Hello</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">asyncio：从原理、源码到实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-06T16:00:00.000Z" title="发表于 2023-10-07 00:00:00">2023-10-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-23T11:03:14.243Z" title="更新于 2023-10-23 19:03:14">2023-10-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/python/">python</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer"/>

<h1 id="Python-asyncio：从原理、源码到实现"><a href="#Python-asyncio：从原理、源码到实现" class="headerlink" title="Python | asyncio：从原理、源码到实现"></a>Python | asyncio：从原理、源码到实现</h1><p>闲谈后 <a href="javascript:void(0">咸鱼学Python</a>;) <em>2019-12-25 14:30</em></p>
<p>选自《源码读Python》</p>
<p><strong>作者：闲谈后</strong></p>
<p><strong><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/64991670">https://zhuanlan.zhihu.com/p/64991670</a></strong></p>
<p>去年的这个时候吧，我开始找工作，招聘启事上说，需要了解 asyncio。</p>
<p>我回去翻了翻书，orz·····</p>
<p>今年，在一次内部技术分享会上，我要分享的内容涉及到一些 python 协程，我又去看 asyncio 的文档。</p>
<p>结果依旧是 orz ····</p>
<p>无奈，我将 asyncio 的源码通读了一遍，然后自己用 python 实现了一个简化版 asyncio，才确信自己应该了解了协程到底是个什么什么玩意儿。</p>
<p>python 的协程实现并不复杂，好的设计本来也不应该复杂。但吊诡的是，如果你没有真正接触使用过 python 中的协程的话，那么很多概念就会看起来很唬人，很复杂。</p>
<p>比如 最基础的 future 是一个容器 或者占位符，代表一个即将进行或者尚未完成的操作。什么玩意儿啊····</p>
<p>我个人原因，比较喜欢写教程，而非写博客。尽管我自己也是个渣渣·····</p>
<p>写这个系列文章的目的，就是希望各位像我一样，没有机会使用 python asyncio、只懂得最基本概念的小白，也能通过<strong>实现一个 asyncio</strong> 来弄清楚协程，到底是个什么东西。其中当然少不了一睹 cpython 与 asyncio 的源码。</p>
<h2 id="01-进程、线程与协程"><a href="#01-进程、线程与协程" class="headerlink" title="01. 进程、线程与协程"></a>01. 进程、线程与协程</h2><p>首先我们要解决的问题 ：进程 线程 协程是什么？</p>
<p>多进程、多线程、协程的模型都是为了解决多个任务同时进行的问题。</p>
<p>多任务系统实现的关键在于暂停当前任务， 保存当前任务的现场、 选择下一个任务、恢复下一个任务的的现场，执行下一个任务</p>
<p>在计算机中，一般我们不称之为现场，而是上下文。</p>
<p>在 《深入理解操作系统》 中，开篇就是 <strong>信息 = 位 + 上下文</strong>，我这里稍微做一个引申</p>
<p><strong>程序 = 指令序列 + 上下文</strong></p>
<p>指令序列的含义是固定的，在计算机中就是 pc 寄存器地址指向的值，也就是 cpu 要执行的指令。但是对于计算机的不同层次，上下文的含义也不尽相同。</p>
<ol>
<li>对于 cpu 来说，上下文就是，操作数寄存器、栈寄存器、状态寄存器等各类寄存器。</li>
<li>对于进程来说，上下文就是，寄存器、信号、分配的内存空间，文件描述符等各类由 cpu 抽象的出来的硬件资源</li>
<li>对于线程来说，上下文就是，寄存器，线程堆栈···</li>
<li>对于一个函数来说，上下文就是当前的命名空间。</li>
<li>那么对于 协程 来说，上下文又是什么呢？</li>
</ol>
<p>而进程的切换是，操作系统控制，也由操作系统执行。</p>
<p>python 的线程切换，是由 python 虚拟机控制，通过一个<strong>系统调用</strong>，来进行线程切换。协程的切换过程完全由程序自身控制。</p>
<ul>
<li>进程的切换 需要 切换系统资源和指令，消耗时间最长</li>
<li>线程的切换，不需要切换系统资源，只需要切换指令、线程堆栈。但这个过程也需要系统调用。</li>
<li>协程的切换都在用户空间内进行，不需要进行系统调用。</li>
</ul>
<p>协程优于线程的主要在于</p>
<ul>
<li>python 线程调度方式是，每执行 100 个字节码或者遇到阻塞就停止当前线程，然后进行一个系统调用，让 os 内核选出下一个线程。但是协程 只会在 阻塞的时候，切换到下一个协程。100个字节码，说多不多，说少不少，你调用两个库函数说不定就没了，因此线程的切换存在很多是无效的切换，当线程数量越大，这种因为调度策略的先天不足带来的性能损耗就越大。</li>
<li>线程需要进行系统调用，协程不需要。系统调用需要进入内核态，无效的调度会让这部分开销显得更大</li>
<li>协程可以自主调度，而线程只能决定合适退出，但是下一个线程是谁则依赖于操作系统。</li>
</ul>
<p>协程 有两种，一种 无栈协程，python 中 以 asyncio 为代表， 一种有栈协程，python 中 以 gevent 为代表。</p>
<p>两者对如何<strong>保存切换上下文</strong>的方式大不一样，我们先看看 asyncio ，以后有机会再补上 gevent 相关的内容。</p>
<h2 id="02-yield-与-yield-from"><a href="#02-yield-与-yield-from" class="headerlink" title="02. yield 与 yield from"></a>02. yield 与 yield from</h2><p>最新版的 python 已经不采用基于 yield 的协程了。但我这里则只用yield 和 yield from 来实现协程，而不使用 await 与 async。这样能更好地展示生成器到协程的全过程，原理也都是相通的。</p>
<p>我们先看一个最简单的 yield 例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ex</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;yield 1&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;yield 2&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">gen = ex()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;启动生成器&quot;</span>)</span><br><span class="line">a = gen.send(<span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;从生成器中获取一个值&#x27;</span>, a)</span><br><span class="line">b = gen.send(<span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;获取到的第二个值&#x27;</span>, b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line"><span class="comment"># 启动生成器</span></span><br><span class="line"><span class="comment"># yield 1</span></span><br><span class="line"><span class="comment"># 从生成器中获取一个值 1</span></span><br><span class="line"><span class="comment"># yield 2</span></span><br><span class="line"><span class="comment"># 获取到的第二个值 2</span></span><br></pre></td></tr></table></figure>
<p>程序序 运行到 第一个 yield 的时候 保存了函数的上下文，并退出了。</p>
<p>接下来 又通过 next 方法再次进入这个 函数，继续运行。在这里，被保存的上下文得到了恢复。</p>
<p>这几行代码里已经展示了一个协程所需要的的全部。<strong>保存上下文 切换运行程序 恢复上下文 重新进入程序</strong>。</p>
<p>接下来，让我们深入看一下，在 cpython 中 yield 的实现原理，这会为我们之后深入了解 gevent 提供参照物。这里需要对 cpython 有一些简单的认知。如果没有相应的基础，不烦看看我的另一篇文章：源码读python（一）</p>
<p>python 中的上下文，被封装成了一个叫做 PyFrameObject 的结构，又称之为栈帧，看一下他的源码：<a target="_blank" rel="noopener" href="https://github.com/xianth123/cpython/blob/master/Include/frameobject.h#L17">https://github.com/xianth123/cpython/blob/master/Include/frameobject.h#L17</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _frame &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    struct _frame *f_back;      /* previous frame, or NULL  上一个栈帧*/</span><br><span class="line">    PyCodeObject *f_code;       /* code segment 代码段*/</span><br><span class="line">    PyObject *f_builtins;       /* builtin symbol table (PyDictObject) 内建变量表*/</span><br><span class="line">    PyObject *f_globals;        /* global symbol table (PyDictObject)  全局变量表*/</span><br><span class="line">    PyObject *f_locals;         /* local symbol table (any mapping)  局部变量表*/</span><br><span class="line">    PyObject **f_valuestack;    /* points after the last local  栈底*/</span><br><span class="line">    /* Next free slot in f_valuestack.  Frame creation sets to f_valuestack.</span><br><span class="line">       Frame evaluation usually NULLs it, but a frame that yields sets it</span><br><span class="line">       to the current stack top. */</span><br><span class="line">    PyObject **f_stacktop;    /*  栈顶 */</span><br><span class="line">    PyObject *f_trace;          /* Trace function */</span><br><span class="line">    char f_trace_lines;         /* Emit per-line trace events? */</span><br><span class="line">    char f_trace_opcodes;       /* Emit per-opcode trace events? */</span><br><span class="line"></span><br><span class="line">    /* Borrowed reference to a generator, or NULL  专为生成器设计的指针*/</span><br><span class="line">    PyObject *f_gen;</span><br><span class="line"></span><br><span class="line">    int f_lasti;                /* Last instruction if called   运行的上一个字节码位置*/</span><br><span class="line">    /* Call PyFrame_GetLineNumber() instead of reading this field</span><br><span class="line">       directly.  As of 2.3 f_lineno is only valid when tracing is</span><br><span class="line">       active (i.e. when f_trace is set).  At other times we use</span><br><span class="line">       PyCode_Addr2Line to calculate the line from the current</span><br><span class="line">       bytecode index. */</span><br><span class="line">    int f_lineno;               /* Current line number   运行字节码对应的python源代码的行数*/</span><br><span class="line">    int f_iblock;               /* index in f_blockstack */</span><br><span class="line">    char f_executing;           /* whether the frame is still executing */</span><br><span class="line">    PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */</span><br><span class="line">    PyObject *f_localsplus[1];  /* locals+stack, dynamically sized */</span><br><span class="line">&#125; PyFrameObject;</span><br></pre></td></tr></table></figure>
<p>我做了简单的注释。</p>
<p>在Python实际的执行中，会产生很多PyFrameObject对象，而这些对象会被链接起来，形成一条执行环境链表。这正是对x86机器上栈帧间关系的模拟。在x86上，栈帧间通过esp指针和ebp指针建立了关系，使新的栈帧在结束之后能顺利回到旧的栈帧中，而Python正是利用f_back来完成这个动作。</p>
<p>另外比较重要的两点就是各种环境变量表，以及程序运行必不可少的堆栈。f_lasti 记录了字节码运行的位置，这也就意味着在 PyFrameObject 中，我们可以随时恢复代码的运行。</p>
<p>接下来看一下 cpython 中对 生成器的定义：<em><a target="_blank" rel="noopener" href="https://github.com/xianth123/cpython/blob/master/Include/genobject.h#L15">https://github.com/xianth123/cpython/blob/master/Include/genobject.h#L15</a></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define _PyGenObject_HEAD(prefix)    \\ 是一个宏而不是一个 struct 结构体                            \</span><br><span class="line">    PyObject_HEAD                                                           \</span><br><span class="line">    /* Note: gi_frame can be NULL if the generator is &quot;finished&quot;  生成器的上下文 PyFrame 指针*/         \</span><br><span class="line">    struct _frame *prefix##_frame;                                          \</span><br><span class="line">    /* True if generator is being executed. */                              \</span><br><span class="line">    char prefix##_running;       \\ 运行状态                                  \</span><br><span class="line">    /* The code object backing the generator */                             \</span><br><span class="line">    PyObject *prefix##_code;                  \\ 字节码                          \</span><br><span class="line">    /* List of weak reference. */                                           \</span><br><span class="line">    PyObject *prefix##_weakreflist;                                         \</span><br><span class="line">    /* Name of the generator. */                                            \</span><br><span class="line">    PyObject *prefix##_name;                                                \</span><br><span class="line">    /* Qualified name of the generator. */                                  \</span><br><span class="line">    PyObject *prefix##_qualname;                                            \</span><br><span class="line">    _PyErr_StackItem prefix##_exc_state;</span><br></pre></td></tr></table></figure>
<p>在 python 中，生成器的语法规则比较特殊，长得像个函数，但是调用之后却返回一个生成器对象。所以他的结构体定义也比较特殊，是一个宏。其中最重要的 是 prefix_frame, ## 是连接符。它指向了一个 PyFrameObject 对象，就是该生成器的上下文。</p>
<p>这个结构体中，有三个最重要的成员</p>
<ol>
<li>指向生成器上下文的 指针</li>
<li>一个指示生成器状态的字符串 未启动，停止，运行，结束</li>
<li>生成器的字节码</li>
</ol>
<p>也就是 上下文 + 指令序列 + 状态</p>
<p>next 与 send 作用是一致的，只是 send 可以传入一个参数，我们来看一下 send 的实现。</p>
<p><em><a target="_blank" rel="noopener" href="https://github.com/xianth123/cpython/blob/3.7/Objects/genobject.c#L151github.com">https://github.com/xianth123/cpython/blob/3.7/Objects/genobject.c#L151github.com</a></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">gen_send_ex(PyGenObject *gen, PyObject *arg, int exc, int closing)</span><br><span class="line">&#123;</span><br><span class="line">    PyThreadState *tstate = PyThreadState_GET();</span><br><span class="line">    PyFrameObject *f = gen-&gt;gi_frame;</span><br><span class="line">    PyObject *result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ·······</span><br><span class="line"></span><br><span class="line">    if (f-&gt;f_lasti == -1) &#123;</span><br><span class="line">        if (arg &amp;&amp; arg != Py_None) &#123;</span><br><span class="line">            const char *msg = &quot;can&#x27;t send non-None value to a &quot;</span><br><span class="line">                              &quot;just-started generator&quot;;</span><br><span class="line">            if (PyCoro_CheckExact(gen)) &#123;</span><br><span class="line">                msg = NON_INIT_CORO_MSG;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (PyAsyncGen_CheckExact(gen)) &#123;</span><br><span class="line">                msg = &quot;can&#x27;t send non-None value to a &quot;</span><br><span class="line">                      &quot;just-started async generator&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            PyErr_SetString(PyExc_TypeError, msg);</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /* Push arg onto the frame&#x27;s value stack */</span><br><span class="line">        result = arg ? arg : Py_None;</span><br><span class="line">        Py_INCREF(result);            /* 如果有参数 就将其压栈*/</span><br><span class="line">        *(f-&gt;f_stacktop++) = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Generators always return to their most recent caller, not</span><br><span class="line">     * necessarily their creator. */</span><br><span class="line">    Py_XINCREF(tstate-&gt;frame);</span><br><span class="line">    assert(f-&gt;f_back == NULL);</span><br><span class="line">    f-&gt;f_back = tstate-&gt;frame;</span><br><span class="line"></span><br><span class="line">    gen-&gt;gi_running = 1;         /* 将生成器设置为运行状态 */</span><br><span class="line">    gen-&gt;gi_exc_state.previous_item = tstate-&gt;exc_info;</span><br><span class="line">    tstate-&gt;exc_info = &amp;gen-&gt;gi_exc_state;</span><br><span class="line">    result = PyEval_EvalFrameEx(f, exc);      /* 正式运行 生成器 得到返回值*/</span><br><span class="line">    tstate-&gt;exc_info = gen-&gt;gi_exc_state.previous_item;</span><br><span class="line">    gen-&gt;gi_exc_state.previous_item = NULL;</span><br><span class="line">    gen-&gt;gi_running = 0;</span><br><span class="line"></span><br><span class="line">    ········</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我省略了一些代码，不过关键的代码也就这些。如果有传入参数，就将参数入栈，用这种方式来向生成器传递值。然后更改生成器运行状态。通过 PyEval_EvalFrameEx 函数运行生成器保存的栈帧，返回值。</p>
<h2 id="03-yield-from"><a href="#03-yield-from" class="headerlink" title="03. yield from"></a>03. yield from</h2><p>在生成器中，可以用 return 返回值，但如果 send 走到 return 语句的时候会报一个StopIteration。return 返回值的 就在 exception 的 value 中。</p>
<p><img src="data:image/svg+xml,%3C%3Fxml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;%3F%3E%3Csvg width=&#39;1px&#39; height=&#39;1px&#39; viewBox=&#39;0 0 1 1&#39; version=&#39;1.1&#39; xmlns=&#39;http://www.w3.org/2000/svg&#39; xmlns:xlink=&#39;http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg stroke=&#39;none&#39; stroke-width=&#39;1&#39; fill=&#39;none&#39; fill-rule=&#39;evenodd&#39; fill-opacity=&#39;0&#39;%3E%3Cg transform=&#39;translate(-249.000000, -126.000000" alt="图片">‘ fill=’%23FFFFFF’%3E%3Crect x=’249’ y=’126’ width=’1’ height=’1’%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)</p>
<p><img src="data:image/svg+xml,%3C%3Fxml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;%3F%3E%3Csvg width=&#39;1px&#39; height=&#39;1px&#39; viewBox=&#39;0 0 1 1&#39; version=&#39;1.1&#39; xmlns=&#39;http://www.w3.org/2000/svg&#39; xmlns:xlink=&#39;http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg stroke=&#39;none&#39; stroke-width=&#39;1&#39; fill=&#39;none&#39; fill-rule=&#39;evenodd&#39; fill-opacity=&#39;0&#39;%3E%3Cg transform=&#39;translate(-249.000000, -126.000000" alt="图片">‘ fill=’%23FFFFFF’%3E%3Crect x=’249’ y=’126’ width=’1’ height=’1’%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)</p>
<p>yield from 有两重性质，一方面，它是<strong>一个表达式</strong>，表达式自然是有值的，他的值，就是yield from 后面生成器 return 的返回值。非常关键的一点，生成器的 yield 语句会向外产出值，但是 return 的值并不会向外产出。想要获得 return 的返回值，要么用 try 语句捕获异常要么用 yield from 表达式获取值。</p>
<p><img src="data:image/svg+xml,%3C%3Fxml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;%3F%3E%3Csvg width=&#39;1px&#39; height=&#39;1px&#39; viewBox=&#39;0 0 1 1&#39; version=&#39;1.1&#39; xmlns=&#39;http://www.w3.org/2000/svg&#39; xmlns:xlink=&#39;http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg stroke=&#39;none&#39; stroke-width=&#39;1&#39; fill=&#39;none&#39; fill-rule=&#39;evenodd&#39; fill-opacity=&#39;0&#39;%3E%3Cg transform=&#39;translate(-249.000000, -126.000000" alt="图片">‘ fill=’%23FFFFFF’%3E%3Crect x=’249’ y=’126’ width=’1’ height=’1’%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)</p>
<p>yield from 另外一点就是，能将内层的生成器的返回值，传到外层。</p>
<p><img src="data:image/svg+xml,%3C%3Fxml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;%3F%3E%3Csvg width=&#39;1px&#39; height=&#39;1px&#39; viewBox=&#39;0 0 1 1&#39; version=&#39;1.1&#39; xmlns=&#39;http://www.w3.org/2000/svg&#39; xmlns:xlink=&#39;http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg stroke=&#39;none&#39; stroke-width=&#39;1&#39; fill=&#39;none&#39; fill-rule=&#39;evenodd&#39; fill-opacity=&#39;0&#39;%3E%3Cg transform=&#39;translate(-249.000000, -126.000000" alt="图片">‘ fill=’%23FFFFFF’%3E%3Crect x=’249’ y=’126’ width=’1’ height=’1’%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)</p>
<p>内层生成器 ex2() 通过 yield from，可以在最外层取出来。</p>
<p>关于 yield from，我觉得讲的最清楚的是 <strong>流畅的python</strong> 16章 协程的有关内容，各位有兴趣可以看看，我这里不做深入展开。</p>
<p>有了 yield from 这个工具，我们便可以将多个生成器串联起来。</p>
<p>我尝试用树形结构来描述一个生成器，也许对协程的理解会有帮助。我们将 yield 的返回值视为 子节点，将生成器本身和 return 的值视为父节点。可以用一个图来描述。</p>
<p><img src="data:image/svg+xml,%3C%3Fxml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;%3F%3E%3Csvg width=&#39;1px&#39; height=&#39;1px&#39; viewBox=&#39;0 0 1 1&#39; version=&#39;1.1&#39; xmlns=&#39;http://www.w3.org/2000/svg&#39; xmlns:xlink=&#39;http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg stroke=&#39;none&#39; stroke-width=&#39;1&#39; fill=&#39;none&#39; fill-rule=&#39;evenodd&#39; fill-opacity=&#39;0&#39;%3E%3Cg transform=&#39;translate(-249.000000, -126.000000" alt="图片">‘ fill=’%23FFFFFF’%3E%3Crect x=’249’ y=’126’ width=’1’ height=’1’%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)</p>
<p>yield from 的意义在于，将这些生成器串联起来形成一颗树，并且提供了一种便捷的方法，将这颗树的叶子节点依次返回。</p>
<p><img src="data:image/svg+xml,%3C%3Fxml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;%3F%3E%3Csvg width=&#39;1px&#39; height=&#39;1px&#39; viewBox=&#39;0 0 1 1&#39; version=&#39;1.1&#39; xmlns=&#39;http://www.w3.org/2000/svg&#39; xmlns:xlink=&#39;http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg stroke=&#39;none&#39; stroke-width=&#39;1&#39; fill=&#39;none&#39; fill-rule=&#39;evenodd&#39; fill-opacity=&#39;0&#39;%3E%3Cg transform=&#39;translate(-249.000000, -126.000000" alt="图片">‘ fill=’%23FFFFFF’%3E%3Crect x=’249’ y=’126’ width=’1’ height=’1’%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)</p>
<p>yield from 将多个生成器连接起来的方式，我们可以使用很简单的方式就可以将所有的 yield 返回值一一提取出来。不断的对根节点的生成器 进行send 操作即可。也就是 gen3.send(None)。</p>
<h2 id="04-从生成器到协程"><a href="#04-从生成器到协程" class="headerlink" title="04. 从生成器到协程"></a>04. 从生成器到协程</h2><p>（本文的协程，单指 asyncio 中的协程）</p>
<p>生成器可以描述为一颗树，生成器是协程实现的基础，那么协程自然也可以描述为一颗树。</p>
<p>在 asyncio 的实现中，协程与生成器最大的区别，就是生成器的叶节点可以是 数字、函数、字符串等各种对象，但是 asyncio 的协程实现中，叶节点只能是 None 或者 future。</p>
<h2 id="05-future"><a href="#05-future" class="headerlink" title="05. future"></a>05. future</h2><p>future 本质上是一个用生成器实现的 回调管理器。</p>
<p>我们之所以使用协程就是为了，在遇到 io、阻塞的时候，将运行的权利交出去，当阻塞事件完成的时候，通过一个回调来唤醒程序继续往下走，并且返回io事件的值。future 就是对这个过程的包装。可以简单写一个伪代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">future</span>():</span><br><span class="line">    callback = future.send  <span class="comment"># 回调函数为 生成器的 send 方法，当然这种写法有问题，此时生成器还未形成</span></span><br><span class="line">    do_something(callback)  <span class="comment"># 进行 io 操作，并将 callback 注册为回调函数</span></span><br><span class="line">    result =  <span class="keyword">yield</span> </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>我们需要将生成器用 yield 送出去，以便回调函数使用，一个 函数不能满足我们的需求，我们将它扩充为一个类，用 yield 返回 self。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Future</span>:</span><br><span class="line"></span><br><span class="line">    _FINISHED = <span class="string">&#x27;finished&#x27;</span></span><br><span class="line">    _PENDING = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line">    _CANCELLED = <span class="string">&#x27;CANCELLED&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.status = self._PENDING</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_result</span>(<span class="params">self, result</span>):</span><br><span class="line">        <span class="comment"># 给future设置结果，并将 future 置为结束状态</span></span><br><span class="line">        self.status = self._FINISHED</span><br><span class="line">        self._result = result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">done</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.status != self._PENDING</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">result</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 获取future 的结果</span></span><br><span class="line">        <span class="keyword">if</span> self.status != self._FINISHED:</span><br><span class="line">            <span class="keyword">raise</span> InvalidStateError(<span class="string">&#x27;future is not ready&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.done():</span><br><span class="line">            self._blocking = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">yield</span> self                              <span class="comment"># 返回自身</span></span><br><span class="line">        <span class="keyword">assert</span> self.done(), <span class="string">&#x27;future not done&#x27;</span>   <span class="comment"># 下一次运行 future 的时候，要确定 future 对应的事件已经运行完毕</span></span><br><span class="line">        <span class="keyword">return</span> self.result()</span><br></pre></td></tr></table></figure>
<p>最关键的就是这个 <strong><em>*</em>iter</strong>*** 方法，第一次启动的时候，将自身设置为 阻塞状态，然后返回 self 。暴露出 set_result 方法让回调函数可以给 future 设置返回值，并且将 future 更改为结束状态。</p>
<p>现在我们可以描绘出协程的树状结构了。所有的叶子节点返回的值 为 self，自然，驱使协程往下走的回调函数，统一变成了最外层的 coro3.send(None)。Coroutine 指代 协程。</p>
<p><img src="data:image/svg+xml,%3C%3Fxml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;%3F%3E%3Csvg width=&#39;1px&#39; height=&#39;1px&#39; viewBox=&#39;0 0 1 1&#39; version=&#39;1.1&#39; xmlns=&#39;http://www.w3.org/2000/svg&#39; xmlns:xlink=&#39;http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg stroke=&#39;none&#39; stroke-width=&#39;1&#39; fill=&#39;none&#39; fill-rule=&#39;evenodd&#39; fill-opacity=&#39;0&#39;%3E%3Cg transform=&#39;translate(-249.000000, -126.000000" alt="图片">‘ fill=’%23FFFFFF’%3E%3Crect x=’249’ y=’126’ width=’1’ height=’1’%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)</p>
<p>那么协程的运行路线就已经很清楚了。coro 通过 coro.send(None) 启动，遇到 io 操作，会用 yield 返回一个 future。io 操作完成之后， 回调函数通过 coro.send(None) 继续往下进行。直到 coro.send(None) 爆出 StopIteration 异常，协程运行完毕。</p>
<p>然而我们不会只运行一个协程，当一个 coro 将自己的控制权交出去之后，谁来接接管呢？</p>
<p>我们需要有一个调度者 也就是 eventloop ，看名字就知道，这是一个事件循环。</p>
<p>所谓的事件驱动模式其实也很简单。事件，就是函数。</p>
<p>事件驱动模式，就是有一个队列，里面存放着一堆函数，从第一个函数开始执行，在函数执行的过程中，可能会有新的函数继续加入到这个队列中。一直到队列中所有的函数被执行完毕，并且再也不会有新的函数被添加到这个队列中。</p>
<p>协程非常适合这种模式，协程的启动就是将 coro.send(None) 加入到 eventloop 的队列中。future 回调完成之后，再将 coro.send(None) 加入到队列中就可以驱使协程继续往下走。</p>
<p>我们来写一个 eventloop.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Eventloop</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._ready = collections.deque() <span class="comment"># 事件队列</span></span><br><span class="line">        self._stopping = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line">        self._stopping = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call_soon</span>(<span class="params">self, callback, *args</span>):</span><br><span class="line">        <span class="comment"># 将事件添加到队列里</span></span><br><span class="line">        handle = Handle(callback, self, *args)</span><br><span class="line">        self._ready.append(handle)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_ready</span>(<span class="params">self, handle</span>):</span><br><span class="line">        <span class="comment"># 将事件添加到队列里</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(handle, Handle):</span><br><span class="line">            self._ready.append(handle)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> EventloopError(<span class="string">&#x27;only handle is allowed to join in ready&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_once</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 执行队列里的事件</span></span><br><span class="line">        ntodo = <span class="built_in">len</span>(self._ready)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ntodo):</span><br><span class="line">            handle = self._ready.popleft()</span><br><span class="line">            handle._run()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_forever</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.run_once()</span><br><span class="line">            <span class="keyword">if</span> self._stopping:</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>通过 run_forever 不断执行队列里的函数，通过 stop 来停止 eventloop。通过 add_ready 将事件添加到自身的队列里。</p>
<p>handle 是对函数和参数的一个简单封装。展示一下他的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Handle</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, callback, loop, *args</span>):</span><br><span class="line">        self._callback = callback</span><br><span class="line">        self._args = args</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_run</span>(<span class="params">self</span>):</span><br><span class="line">        self._callback(*self._args)</span><br></pre></td></tr></table></figure>
<p>因为 协程的推动需要将 coro.send(None) 添加到 eventloop 里，所以将 eventloop 设置为一个全局变量，用一个函数来获取他。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_event_loop = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_event_loop</span>():</span><br><span class="line">    <span class="keyword">global</span> _event_loop</span><br><span class="line">    <span class="keyword">if</span> _event_loop <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        _event_loop = Eventloop()</span><br><span class="line">    <span class="keyword">return</span> _event_loop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Eventloop</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>这样写的坏处是，所有线程的 eventloop 都是同一个，不能支持多线程。如果想支持多线程，那么get_event_loop 获取的应该是一个线程里的全局变量。为了简单起见，我们暂时采用简单的实现，多线程版本后期再加上。</p>
<p>因为有了 eventloop, future 也需要改变一下。主要是增加了 add_done_callback 接口，为 future 增加回调函数。</p>
<p>当为 future 的 set_result 的时候，会执行 _schedule_callbacks。他的作用是将回调函数列表添加到 eventloop 的函数运行队列里，通过 eventloop，来运行回调函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Future</span>:</span><br><span class="line"></span><br><span class="line">    _FINISHED = <span class="string">&#x27;finished&#x27;</span></span><br><span class="line">    _PENDING = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line">    _CANCELLED = <span class="string">&#x27;CANCELLED&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, loop=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> loop <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self._loop = get_event_loop() <span class="comment"># 获取当前的 eventloop</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._loop = loop</span><br><span class="line">        self._callbacks = []</span><br><span class="line">        self.status = self._PENDING</span><br><span class="line">        self._blocking = <span class="literal">False</span></span><br><span class="line">        self._result = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_schedule_callbacks</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 将回调函数添加到事件队列里，eventloop 稍后会运行</span></span><br><span class="line">        <span class="keyword">for</span> callbacks <span class="keyword">in</span> self._callbacks:</span><br><span class="line">            self._loop.add_ready(callbacks)</span><br><span class="line">        self._callbacks = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_result</span>(<span class="params">self, result</span>):</span><br><span class="line">        self.status = self._FINISHED</span><br><span class="line">        self._result = result</span><br><span class="line">        self._schedule_callbacks()  <span class="comment"># future 完成后，执行回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_done_callback</span>(<span class="params">self, callback, *args</span>):</span><br><span class="line">        <span class="comment"># 为 future 增加回调函数</span></span><br><span class="line">        <span class="keyword">if</span> self.done():</span><br><span class="line">            self._loop.call_soon(callback, *args)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            handle = Handle(callback, self._loop, *args)</span><br><span class="line">            self._callbacks.append(handle)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">done</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.status != self._PENDING</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">result</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.status != self._FINISHED:</span><br><span class="line">            <span class="keyword">raise</span> InvalidStateError(<span class="string">&#x27;future is not ready&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.done():</span><br><span class="line">            self._blocking = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">yield</span> self</span><br><span class="line">        <span class="keyword">assert</span> self.done(), <span class="string">&#x27;future not done&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.result()</span><br></pre></td></tr></table></figure>
<p>我们还需要用 task 来对协程本身做一层封装。task 是 future 的子类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>(<span class="title class_ inherited__">Future</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, coro, loop=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(loop=loop)</span><br><span class="line">        self._coro = coro    <span class="comment"># 协程</span></span><br><span class="line">        self._loop.call_soon(self._step) <span class="comment"># 启动协程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_step</span>(<span class="params">self, exc=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> exc <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                result = self._coro.send(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = self._coro.throw(exc)   <span class="comment"># 有异常，则抛出异常</span></span><br><span class="line">        <span class="keyword">except</span> StopIteration <span class="keyword">as</span> exc:   <span class="comment"># 说明协程已经执行完毕，为协程设置值</span></span><br><span class="line">            self.set_result(exc.value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(result, Future):</span><br><span class="line">                <span class="keyword">if</span> result._blocking:</span><br><span class="line">                    self._blocking = <span class="literal">False</span></span><br><span class="line">                    result.add_done_callback(self._wakeup, result)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self._loop.call_soon(</span><br><span class="line">                        self._step, RuntimeError(<span class="string">&#x27;你是不是用了 yield 才导致这个error?&#x27;</span>)</span><br><span class="line">                    )</span><br><span class="line">            <span class="keyword">elif</span> result <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                self._loop.call_soon(self._step)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._loop.call_soon(self._step, RuntimeError(<span class="string">&#x27;你产生了一个不合规范的值&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_wakeup</span>(<span class="params">self, future</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            future.result()  <span class="comment"># 查看future 运行是否有异常</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">            self._step(exc)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._step()</span><br></pre></td></tr></table></figure>
<p>task 的 _coro 就是协程。task只有两个方法。_step 实际上就是执行 _coro.send(None)，根据协程的产出值来进行下一步。当返回了一个 future，如果是阻塞中的状态 _blocking ，就将唤醒自己作为 future 的回调函数。future 回调完毕之后，就会唤醒协程进行下一步。</p>
<p>如果产出一个 None，那么就无须阻塞，继续往下进行。将self._step 添加到 eventloop 的事件队列里。等待 eventloop 稍后执行。</p>
<p>比较有意思的是他的异常处理方式， _step() 可以接受一个异常，并将其抛出。如果yield 返回了不规范的值，并不会直接爆出异常，而是将异常作为 _step 的参数，在下一次运行的时候抛出来。</p>
<h2 id="06-写在最后"><a href="#06-写在最后" class="headerlink" title="06. 写在最后"></a>06. 写在最后</h2><p>asyncio 中协程最核心的设计大概就是这样。加起来不到两百行代码。</p>
<p>当然，这些还远远不够。</p>
<p>以此为框架，我会慢慢增添定时任务的处理方式, 就像 asyncio.sleep()就是通过定时任务实现的 , 添加多线程支持（基于 threeding），添加对 socket 事件的监听(基于 selector 模块)，我们还可以此基础上实现 http 的 request(get\post等) 功能，原版的 asyncio 模块都没有这个功能。这才算实现了一个简单的异步。</p>
<p>自己在工作中没什么机会使用 asyncio，理解可能多有偏差，有什么错谬的地方还请各位指出，有什么宝贵意见也请说明。还请尽管吐槽。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://kokomisukisuki.github.io">sagonimikakokomi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://kokomisukisuki.github.io/2023/10/07/Python%20%20asyncio%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E3%80%81%E6%BA%90%E7%A0%81%E5%88%B0%E5%AE%9E%E7%8E%B0/">https://kokomisukisuki.github.io/2023/10/07/Python%20%20asyncio%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E3%80%81%E6%BA%90%E7%A0%81%E5%88%B0%E5%AE%9E%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://kokomisukisuki.github.io" target="_blank">Hello</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python%E5%9F%BA%E7%A1%80/">python基础</a></div><div class="post_share"><div class="social-share" data-image="https://www.helloimg.com/images/2023/10/03/oHEpr6.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/07/Python%20%20Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3/" title="Python学习之多进程详解"><img class="cover" src="https://www.helloimg.com/images/2023/10/03/oHEI6z.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python学习之多进程详解</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/07/Python%20%20%E7%94%A8%20Hypothesis%20%E5%BF%AB%E9%80%9F%E6%B5%8B%E8%AF%95%E4%BD%A0%E7%9A%84%20Python%20%E4%BB%A3%E7%A0%81/" title="Python | 用 Hypothesis 快速测试你的 Python 代码"><img class="cover" src="https://www.helloimg.com/images/2023/10/03/oHqdKE.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Python | 用 Hypothesis 快速测试你的 Python 代码</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/10/07/Python%20%20Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/" title="Python学习之多线程详解"><img class="cover" src="https://www.helloimg.com/images/2023/10/03/oHE8ZA.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">Python学习之多线程详解</div></div></a></div><div><a href="/2023/10/07/Python%20%20Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3/" title="Python学习之多进程详解"><img class="cover" src="https://www.helloimg.com/images/2023/10/03/oHEI6z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">Python学习之多进程详解</div></div></a></div><div><a href="/2023/10/17/cookie%E8%AF%A6%E8%A7%A3/" title="cookie详解"><img class="cover" src="https://www.helloimg.com/images/2023/10/03/oHENJM.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-17</div><div class="title">cookie详解</div></div></a></div><div><a href="/2023/10/17/python%E5%9F%BA%E7%A1%80raise/" title="python基础raise"><img class="cover" src="https://www.helloimg.com/images/2023/10/03/oHXBKY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-17</div><div class="title">python基础raise</div></div></a></div><div><a href="/2023/10/17/python%E4%B8%AD%20r'',%20b'',%20u'',%20f''%20%E7%9A%84%E5%90%AB%E4%B9%89/" title="python中 r&#39;&#39;, b&#39;&#39;, u&#39;&#39;, f&#39;&#39; 的含义"><img class="cover" src="https://www.helloimg.com/images/2023/10/03/oHEwug.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-17</div><div class="title">python中 r&#39;&#39;, b&#39;&#39;, u&#39;&#39;, f&#39;&#39; 的含义</div></div></a></div><div><a href="/2023/10/15/%E3%80%90%E5%B9%B2%E8%B4%A7%E3%80%91%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%81/" title="一文详解Python多线程、多进程！"><img class="cover" src="https://www.helloimg.com/images/2023/10/03/oHJyqP.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-15</div><div class="title">一文详解Python多线程、多进程！</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Python-asyncio%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E3%80%81%E6%BA%90%E7%A0%81%E5%88%B0%E5%AE%9E%E7%8E%B0"><span class="toc-text">Python | asyncio：从原理、源码到实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B"><span class="toc-text">01. 进程、线程与协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-yield-%E4%B8%8E-yield-from"><span class="toc-text">02. yield 与 yield from</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-yield-from"><span class="toc-text">03. yield from</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-%E4%BB%8E%E7%94%9F%E6%88%90%E5%99%A8%E5%88%B0%E5%8D%8F%E7%A8%8B"><span class="toc-text">04. 从生成器到协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-future"><span class="toc-text">05. future</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06-%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="toc-text">06. 写在最后</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By sagonimikakokomi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">welcome</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async defer src='/js/diy.js'></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>